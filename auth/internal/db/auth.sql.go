// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.25.0
// source: auth.sql

package db

import (
	"context"

	"github.com/jackc/pgx/v5/pgtype"
)

const createRecoveryAccount = `-- name: CreateRecoveryAccount :one
INSERT INTO recover_accounts (
    id,
    uid,
    email,
    secret_key,
    expired_at
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, uid, email, secret_key, is_used, created_at, expired_at
`

type CreateRecoveryAccountParams struct {
	ID        string           `json:"id"`
	Uid       string           `json:"uid"`
	Email     string           `json:"email"`
	SecretKey string           `json:"secret_key"`
	ExpiredAt pgtype.Timestamp `json:"expired_at"`
}

func (q *Queries) CreateRecoveryAccount(ctx context.Context, arg CreateRecoveryAccountParams) (RecoverAccount, error) {
	row := q.db.QueryRow(ctx, createRecoveryAccount,
		arg.ID,
		arg.Uid,
		arg.Email,
		arg.SecretKey,
		arg.ExpiredAt,
	)
	var i RecoverAccount
	err := row.Scan(
		&i.ID,
		&i.Uid,
		&i.Email,
		&i.SecretKey,
		&i.IsUsed,
		&i.CreatedAt,
		&i.ExpiredAt,
	)
	return i, err
}

const createRefreshToken = `-- name: CreateRefreshToken :one
INSERT INTO "sessions" (
    id,
    uid,
    refresh_token,
    user_agent,
    client_ip,
    expired_at
) VALUES (
    $1, $2, $3, $4, $5, $6
) RETURNING id, uid, refresh_token, user_agent, client_ip, is_blocked, expired_at, created_at
`

type CreateRefreshTokenParams struct {
	ID           string           `json:"id"`
	Uid          string           `json:"uid"`
	RefreshToken pgtype.Text      `json:"refresh_token"`
	UserAgent    pgtype.Text      `json:"user_agent"`
	ClientIp     pgtype.Text      `json:"client_ip"`
	ExpiredAt    pgtype.Timestamp `json:"expired_at"`
}

func (q *Queries) CreateRefreshToken(ctx context.Context, arg CreateRefreshTokenParams) (Session, error) {
	row := q.db.QueryRow(ctx, createRefreshToken,
		arg.ID,
		arg.Uid,
		arg.RefreshToken,
		arg.UserAgent,
		arg.ClientIp,
		arg.ExpiredAt,
	)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.Uid,
		&i.RefreshToken,
		&i.UserAgent,
		&i.ClientIp,
		&i.IsBlocked,
		&i.ExpiredAt,
		&i.CreatedAt,
	)
	return i, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
    uid,
    phone_number,
    email,
    username,
    first_name,
    last_name,
    password,
    is_active,
    is_verified,
    secret_key,
    last_login
) VALUES (
    $1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11
) RETURNING id, uid, username, email, first_name, last_name, password, phone_number, secret_key, is_active, is_verified, last_login, date_joined
`

type CreateUserParams struct {
	Uid         string           `json:"uid"`
	PhoneNumber string           `json:"phone_number"`
	Email       string           `json:"email"`
	Username    string           `json:"username"`
	FirstName   string           `json:"first_name"`
	LastName    pgtype.Text      `json:"last_name"`
	Password    string           `json:"password"`
	IsActive    pgtype.Bool      `json:"is_active"`
	IsVerified  pgtype.Bool      `json:"is_verified"`
	SecretKey   string           `json:"secret_key"`
	LastLogin   pgtype.Timestamp `json:"last_login"`
}

func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRow(ctx, createUser,
		arg.Uid,
		arg.PhoneNumber,
		arg.Email,
		arg.Username,
		arg.FirstName,
		arg.LastName,
		arg.Password,
		arg.IsActive,
		arg.IsVerified,
		arg.SecretKey,
		arg.LastLogin,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Uid,
		&i.Username,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.Password,
		&i.PhoneNumber,
		&i.SecretKey,
		&i.IsActive,
		&i.IsVerified,
		&i.LastLogin,
		&i.DateJoined,
	)
	return i, err
}

const createUserOTP = `-- name: CreateUserOTP :exec
INSERT INTO user_otps (
    uid,
    otp_enabled,
    otp_verified,
    otp_secret,
    otp_url
) VALUES (
    $1, $2, $3, $4, $5
)
`

type CreateUserOTPParams struct {
	Uid         string      `json:"uid"`
	OtpEnabled  pgtype.Bool `json:"otp_enabled"`
	OtpVerified pgtype.Bool `json:"otp_verified"`
	OtpSecret   pgtype.Text `json:"otp_secret"`
	OtpUrl      pgtype.Text `json:"otp_url"`
}

func (q *Queries) CreateUserOTP(ctx context.Context, arg CreateUserOTPParams) error {
	_, err := q.db.Exec(ctx, createUserOTP,
		arg.Uid,
		arg.OtpEnabled,
		arg.OtpVerified,
		arg.OtpSecret,
		arg.OtpUrl,
	)
	return err
}

const createVerifyEmail = `-- name: CreateVerifyEmail :one
INSERT INTO verify_emails (
    id,
    uid,
    email,
    secret_key,
    expired_at
) VALUES (
    $1, $2, $3, $4, $5
) RETURNING id, uid, email, secret_key, is_used, created_at, expired_at
`

type CreateVerifyEmailParams struct {
	ID        string           `json:"id"`
	Uid       string           `json:"uid"`
	Email     string           `json:"email"`
	SecretKey string           `json:"secret_key"`
	ExpiredAt pgtype.Timestamp `json:"expired_at"`
}

func (q *Queries) CreateVerifyEmail(ctx context.Context, arg CreateVerifyEmailParams) (VerifyEmail, error) {
	row := q.db.QueryRow(ctx, createVerifyEmail,
		arg.ID,
		arg.Uid,
		arg.Email,
		arg.SecretKey,
		arg.ExpiredAt,
	)
	var i VerifyEmail
	err := row.Scan(
		&i.ID,
		&i.Uid,
		&i.Email,
		&i.SecretKey,
		&i.IsUsed,
		&i.CreatedAt,
		&i.ExpiredAt,
	)
	return i, err
}

const deleteSessionUser = `-- name: DeleteSessionUser :exec
DELETE FROM "sessions" WHERE uid = $1
`

func (q *Queries) DeleteSessionUser(ctx context.Context, uid string) error {
	_, err := q.db.Exec(ctx, deleteSessionUser, uid)
	return err
}

const getRecoverAccount = `-- name: GetRecoverAccount :one
SELECT id, uid, email, secret_key, is_used, created_at, expired_at FROM recover_accounts WHERE uid = $1 AND secret_key = $2
`

type GetRecoverAccountParams struct {
	Uid       string `json:"uid"`
	SecretKey string `json:"secret_key"`
}

func (q *Queries) GetRecoverAccount(ctx context.Context, arg GetRecoverAccountParams) (RecoverAccount, error) {
	row := q.db.QueryRow(ctx, getRecoverAccount, arg.Uid, arg.SecretKey)
	var i RecoverAccount
	err := row.Scan(
		&i.ID,
		&i.Uid,
		&i.Email,
		&i.SecretKey,
		&i.IsUsed,
		&i.CreatedAt,
		&i.ExpiredAt,
	)
	return i, err
}

const getRefreshToken = `-- name: GetRefreshToken :one
SELECT id, uid, refresh_token, user_agent, client_ip, is_blocked, expired_at, created_at FROM "sessions" WHERE id = $1
`

func (q *Queries) GetRefreshToken(ctx context.Context, id string) (Session, error) {
	row := q.db.QueryRow(ctx, getRefreshToken, id)
	var i Session
	err := row.Scan(
		&i.ID,
		&i.Uid,
		&i.RefreshToken,
		&i.UserAgent,
		&i.ClientIp,
		&i.IsBlocked,
		&i.ExpiredAt,
		&i.CreatedAt,
	)
	return i, err
}

const getUserByEmailAndUsername = `-- name: GetUserByEmailAndUsername :one
SELECT id, uid, username, email, first_name, last_name, password, phone_number, secret_key, is_active, is_verified, last_login, date_joined FROM users WHERE username = $1 AND email = $2
`

type GetUserByEmailAndUsernameParams struct {
	Username string `json:"username"`
	Email    string `json:"email"`
}

func (q *Queries) GetUserByEmailAndUsername(ctx context.Context, arg GetUserByEmailAndUsernameParams) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmailAndUsername, arg.Username, arg.Email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Uid,
		&i.Username,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.Password,
		&i.PhoneNumber,
		&i.SecretKey,
		&i.IsActive,
		&i.IsVerified,
		&i.LastLogin,
		&i.DateJoined,
	)
	return i, err
}

const getUserByEmailOrUsername = `-- name: GetUserByEmailOrUsername :one
SELECT id, uid, username, email, first_name, last_name, password, phone_number, secret_key, is_active, is_verified, last_login, date_joined FROM users WHERE username = $1 OR email = $1 AND is_active = TRUE
`

func (q *Queries) GetUserByEmailOrUsername(ctx context.Context, username string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByEmailOrUsername, username)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Uid,
		&i.Username,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.Password,
		&i.PhoneNumber,
		&i.SecretKey,
		&i.IsActive,
		&i.IsVerified,
		&i.LastLogin,
		&i.DateJoined,
	)
	return i, err
}

const getUserByUid = `-- name: GetUserByUid :one
SELECT id, uid, username, email, first_name, last_name, password, phone_number, secret_key, is_active, is_verified, last_login, date_joined FROM users WHERE uid = $1 LIMIT 1
`

func (q *Queries) GetUserByUid(ctx context.Context, uid string) (User, error) {
	row := q.db.QueryRow(ctx, getUserByUid, uid)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Uid,
		&i.Username,
		&i.Email,
		&i.FirstName,
		&i.LastName,
		&i.Password,
		&i.PhoneNumber,
		&i.SecretKey,
		&i.IsActive,
		&i.IsVerified,
		&i.LastLogin,
		&i.DateJoined,
	)
	return i, err
}

const getVerifyEmail = `-- name: GetVerifyEmail :one
SELECT id, uid, email, secret_key, is_used, created_at, expired_at FROM verify_emails WHERE uid = $1 AND secret_key = $2
`

type GetVerifyEmailParams struct {
	Uid       string `json:"uid"`
	SecretKey string `json:"secret_key"`
}

func (q *Queries) GetVerifyEmail(ctx context.Context, arg GetVerifyEmailParams) (VerifyEmail, error) {
	row := q.db.QueryRow(ctx, getVerifyEmail, arg.Uid, arg.SecretKey)
	var i VerifyEmail
	err := row.Scan(
		&i.ID,
		&i.Uid,
		&i.Email,
		&i.SecretKey,
		&i.IsUsed,
		&i.CreatedAt,
		&i.ExpiredAt,
	)
	return i, err
}

const updateRecoverAccount = `-- name: UpdateRecoverAccount :exec
UPDATE recover_accounts
SET 
    is_used = TRUE
WHERE 
    uid = $1 
    AND secret_key = $2
    AND is_used = FALSE
`

type UpdateRecoverAccountParams struct {
	Uid       string `json:"uid"`
	SecretKey string `json:"secret_key"`
}

func (q *Queries) UpdateRecoverAccount(ctx context.Context, arg UpdateRecoverAccountParams) error {
	_, err := q.db.Exec(ctx, updateRecoverAccount, arg.Uid, arg.SecretKey)
	return err
}

const updateUserActive = `-- name: UpdateUserActive :exec
UPDATE users SET
    is_active = $1
WHERE "uid" = $2
`

type UpdateUserActiveParams struct {
	IsActive pgtype.Bool `json:"is_active"`
	Uid      string      `json:"uid"`
}

func (q *Queries) UpdateUserActive(ctx context.Context, arg UpdateUserActiveParams) error {
	_, err := q.db.Exec(ctx, updateUserActive, arg.IsActive, arg.Uid)
	return err
}

const updateUserLastLogin = `-- name: UpdateUserLastLogin :exec
UPDATE users SET
    last_login = 'now()'
WHERE "uid" = $1
`

func (q *Queries) UpdateUserLastLogin(ctx context.Context, uid string) error {
	_, err := q.db.Exec(ctx, updateUserLastLogin, uid)
	return err
}

const updateUserPassword = `-- name: UpdateUserPassword :exec
UPDATE users SET 
    password = $1
WHERE "uid" = $2
`

type UpdateUserPasswordParams struct {
	Password string `json:"password"`
	Uid      string `json:"uid"`
}

func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) error {
	_, err := q.db.Exec(ctx, updateUserPassword, arg.Password, arg.Uid)
	return err
}

const updateUserVerified = `-- name: UpdateUserVerified :exec
UPDATE users SET 
    is_verified = $1 
WHERE "uid" = $2
`

type UpdateUserVerifiedParams struct {
	IsVerified pgtype.Bool `json:"is_verified"`
	Uid        string      `json:"uid"`
}

func (q *Queries) UpdateUserVerified(ctx context.Context, arg UpdateUserVerifiedParams) error {
	_, err := q.db.Exec(ctx, updateUserVerified, arg.IsVerified, arg.Uid)
	return err
}

const updateVerifyEmail = `-- name: UpdateVerifyEmail :exec
UPDATE verify_emails
SET 
    is_used = TRUE
WHERE 
    uid = $1 
    AND secret_key = $2
    AND is_used = FALSE
`

type UpdateVerifyEmailParams struct {
	Uid       string `json:"uid"`
	SecretKey string `json:"secret_key"`
}

func (q *Queries) UpdateVerifyEmail(ctx context.Context, arg UpdateVerifyEmailParams) error {
	_, err := q.db.Exec(ctx, updateVerifyEmail, arg.Uid, arg.SecretKey)
	return err
}
